// ============================================
// üöÄ ADVANCED FEATURES
// Pattern Lock, Printing, & Real-time Dashboard
// ============================================

// ============================================
// üì± PATTERN LOCK SYSTEM
// ============================================

class PatternLock {
    constructor(containerId, inputId) {
        this.container = document.getElementById(containerId);
        this.input = document.getElementById(inputId);
        this.dots = [];
        this.path = [];
        this.isDrawing = false;

        if (!this.container) return;

        this.init();
    }

    init() {
        this.container.innerHTML = `
            <div class="pattern-grid" id="pattern-grid">
                <canvas id="pattern-canvas"></canvas>
                <!-- Dots generated by JS -->
            </div>
            <div class="pattern-actions">
                <button type="button" class="primary-btn small" onclick="patternLock.clear()">Limpar</button>
            </div>
        `;

        const grid = document.getElementById('pattern-grid');

        // Create 9 dots
        for (let i = 1; i <= 9; i++) {
            const dot = document.createElement('div');
            dot.className = 'pattern-dot';
            dot.dataset.id = i;
            dot.addEventListener('mousedown', (e) => this.startDraw(e, i));
            dot.addEventListener('mouseenter', (e) => this.enterDot(e, i));

            // Touch support
            dot.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.startDraw(e, i);
            });

            grid.appendChild(dot);
            this.dots.push(dot);
        }

        // Global events
        document.addEventListener('mouseup', () => this.endDraw());
        document.addEventListener('touchend', () => this.endDraw());

        // Canvas setup
        this.canvas = document.getElementById('pattern-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
    }

    resizeCanvas() {
        const grid = document.getElementById('pattern-grid');
        this.canvas.width = grid.offsetWidth;
        this.canvas.height = grid.offsetHeight;
    }

    startDraw(e, id) {
        this.isDrawing = true;
        this.path = [id];
        this.updateVisuals();
    }

    enterDot(e, id) {
        if (this.isDrawing && !this.path.includes(id)) {
            this.path.push(id);
            this.updateVisuals();
        }
    }

    endDraw() {
        if (this.isDrawing) {
            this.isDrawing = false;
            this.savePattern();
        }
    }

    updateVisuals() {
        // Reset dots
        this.dots.forEach(dot => dot.classList.remove('active'));

        // Activate path dots
        this.path.forEach(id => {
            const dot = this.dots.find(d => parseInt(d.dataset.id) === id);
            if (dot) dot.classList.add('active');
        });

        // Draw lines
        this.drawLines();
    }

    drawLines() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.path.length < 2) return;

        this.ctx.beginPath();
        this.ctx.lineWidth = 5;
        this.ctx.strokeStyle = '#667eea'; // Primary color
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        const getDotPos = (id) => {
            const dot = this.dots.find(d => parseInt(d.dataset.id) === id);
            return {
                x: dot.offsetLeft + dot.offsetWidth / 2,
                y: dot.offsetTop + dot.offsetHeight / 2
            };
        };

        const start = getDotPos(this.path[0]);
        this.ctx.moveTo(start.x, start.y);

        for (let i = 1; i < this.path.length; i++) {
            const pos = getDotPos(this.path[i]);
            this.ctx.lineTo(pos.x, pos.y);
        }

        this.ctx.stroke();
    }

    savePattern() {
        if (this.input) {
            this.input.value = this.path.join('-');
            console.log('Pattern saved:', this.path.join('-'));
        }
    }

    clear() {
        this.path = [];
        this.updateVisuals();
        if (this.input) this.input.value = '';
    }
}

// ============================================
// üñ®Ô∏è PRINTING SYSTEM
// ============================================

function printOrder(orderId, type = 'a4') {
    const order = serviceOrders.find(o => o.id == orderId);
    if (!order) return showToast('Erro', 'Ordem n√£o encontrada');

    const client = clients.find(c => c.name === order.client) || { name: order.client, phone: 'N/A' };

    const printContent = `
        <div class="${type === 'thermal' ? 'print-thermal' : 'print-a4'}">
            <div class="print-header">
                <div class="print-logo">
                    <h1>TechAssist</h1>
                    <p>Assist√™ncia T√©cnica Especializada</p>
                </div>
                <p>CNPJ: 00.000.000/0001-00</p>
                <p>Tel: (11) 99999-9999</p>
            </div>
            
            <div class="print-info">
                <div>
                    <strong>OS #:</strong> ${order.id}<br>
                    <strong>Data:</strong> ${new Date(order.createdAt).toLocaleDateString()}<br>
                    <strong>Status:</strong> ${translateStatus(order.status)}
                </div>
                <div>
                    <strong>Cliente:</strong> ${client.name}<br>
                    <strong>Tel:</strong> ${client.phone || 'N/A'}<br>
                    <strong>CPF:</strong> ${client.document || 'N/A'}
                </div>
            </div>
            
            <div class="print-section">
                <h3>Aparelho</h3>
                <p><strong>Equipamento:</strong> ${order.device || 'Smartphone'}</p>
                <p><strong>Defeito:</strong> ${order.subject}</p>
                <p><strong>Senha (Padr√£o):</strong> ${order.pattern || 'N√£o informada'}</p>
            </div>
            
            <div class="print-section">
                <h3>Servi√ßos & Pe√ßas</h3>
                <table class="print-table">
                    <thead>
                        <tr>
                            <th>Descri√ß√£o</th>
                            <th>Qtd</th>
                            <th>Valor</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Servi√ßo T√©cnico</td>
                            <td>1</td>
                            <td>R$ ${order.budget || '0,00'}</td>
                        </tr>
                    </tbody>
                    <tfoot>
                        <tr>
                            <td colspan="2" style="text-align:right"><strong>Total:</strong></td>
                            <td><strong>R$ ${order.budget || '0,00'}</strong></td>
                        </tr>
                    </tfoot>
                </table>
            </div>
            
            <div class="print-section">
                <h3>Observa√ß√µes</h3>
                <p>Garantia de 90 dias para o servi√ßo realizado.</p>
                <p>Aparelhos n√£o retirados em 90 dias ser√£o vendidos para custear pe√ßas.</p>
            </div>
            
            <div class="signature-line">
                <center>Assinatura do Cliente</center>
            </div>
            
            <div class="print-footer">
                <p>Impresso em ${new Date().toLocaleString()} via TechAssist</p>
            </div>
        </div>
    `;

    // Create print area
    let printArea = document.getElementById('print-area');
    if (!printArea) {
        printArea = document.createElement('div');
        printArea.id = 'print-area';
        document.body.appendChild(printArea);
    }

    printArea.innerHTML = printContent;

    // Trigger print
    window.print();

    // Cleanup
    setTimeout(() => {
        printArea.innerHTML = '';
    }, 1000);
}

function translateStatus(status) {
    const map = {
        'open': 'Aberto',
        'pending': 'Em Andamento',
        'resolved': 'Conclu√≠do',
        'closed': 'Fechado'
    };
    return map[status] || status;
}

// ============================================
// üìä REAL-TIME DASHBOARD UPDATES
// ============================================

function updateDashboardStats() {
    // 1. Active Orders (Open + Pending)
    const activeOrders = serviceOrders.filter(o => o.status === 'open' || o.status === 'pending').length;
    const activeEl = document.getElementById('stat-active-orders');
    if (activeEl) activeEl.textContent = activeOrders;

    // 2. Completed Today
    const today = new Date().toISOString().split('T')[0];
    const completedToday = serviceOrders.filter(o =>
        o.status === 'resolved' && o.updatedAt && o.updatedAt.startsWith(today)
    ).length;
    const completedEl = document.getElementById('stat-completed-today');
    if (completedEl) completedEl.textContent = completedToday;

    // 3. Revenue (Month) - From Sales + Orders
    const currentMonth = new Date().getMonth();
    let revenue = 0;

    // Sum Sales
    if (window.sales) {
        sales.forEach(s => {
            if (new Date(s.date).getMonth() === currentMonth) {
                revenue += parseFloat(s.total);
            }
        });
    }

    // Sum Paid Orders (Simplified)
    serviceOrders.forEach(o => {
        if (o.status === 'resolved' && new Date(o.createdAt).getMonth() === currentMonth) {
            revenue += parseFloat(o.budget || 0);
        }
    });

    const revenueEl = document.getElementById('stat-revenue');
    if (revenueEl) revenueEl.textContent = `R$ ${revenue.toFixed(2)}`;

    // 4. New Clients (Month)
    const newClients = clients.filter(c =>
        new Date(c.createdAt).getMonth() === currentMonth
    ).length;
    const clientsEl = document.getElementById('stat-new-clients');
    if (clientsEl) clientsEl.textContent = newClients;

    console.log('üìä Dashboard Updated with Real Data!');
}

// Export functions
window.PatternLock = PatternLock;
window.printOrder = printOrder;
window.updateDashboardStats = updateDashboardStats;

// Auto-init dashboard updates
document.addEventListener('DOMContentLoaded', () => {
    // Update every 30 seconds
    updateDashboardStats();
    setInterval(updateDashboardStats, 30000);
});
